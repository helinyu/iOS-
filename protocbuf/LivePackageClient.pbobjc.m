// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: LivePackage_client.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "LivePackageClient.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - LivePackageClientRoot

@implementation LivePackageClientRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - LivePackageClientRoot_FileDescriptor

static GPBFileDescriptor *LivePackageClientRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - CreateRoomRequest

@implementation CreateRoomRequest

@dynamic hasAdmin, admin;

typedef struct CreateRoomRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *admin;
} CreateRoomRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "admin",
        .dataTypeSpecific.className = NULL,
        .number = CreateRoomRequest_FieldNumber_Admin,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CreateRoomRequest__storage_, admin),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateRoomRequest class]
                                     rootClass:[LivePackageClientRoot class]
                                          file:LivePackageClientRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateRoomRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateRoomResponse

@implementation CreateRoomResponse

@dynamic hasResult, result;

typedef struct CreateRoomResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t result;
} CreateRoomResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.className = NULL,
        .number = CreateRoomResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CreateRoomResponse__storage_, result),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateRoomResponse class]
                                     rootClass:[LivePackageClientRoot class]
                                          file:LivePackageClientRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateRoomResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EnterRoomRequest

@implementation EnterRoomRequest

@dynamic hasRoomId, roomId;

typedef struct EnterRoomRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *roomId;
} EnterRoomRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = EnterRoomRequest_FieldNumber_RoomId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EnterRoomRequest__storage_, roomId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EnterRoomRequest class]
                                     rootClass:[LivePackageClientRoot class]
                                          file:LivePackageClientRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EnterRoomRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserInfo

@implementation UserInfo

@dynamic hasUserId, userId;
@dynamic hasNickname, nickname;
@dynamic hasHeadURL, headURL;

typedef struct UserInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSString *nickname;
  NSString *headURL;
} UserInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserInfo__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickname",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_Nickname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserInfo__storage_, nickname),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "headURL",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_HeadURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserInfo__storage_, headURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserInfo class]
                                     rootClass:[LivePackageClientRoot class]
                                          file:LivePackageClientRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001F\000\002H\000\003E!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EnterRoomResponse

@implementation EnterRoomResponse

@dynamic hasResult, result;
@dynamic usersArray, usersArray_Count;
@dynamic hasStatement, statement;
@dynamic hasId_p, id_p;
@dynamic hasLikeTotal, likeTotal;

typedef struct EnterRoomResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t result;
  NSMutableArray *usersArray;
  EnterRoomResponse_Statement *statement;
  NSString *id_p;
  int64_t likeTotal;
} EnterRoomResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.className = NULL,
        .number = EnterRoomResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EnterRoomResponse__storage_, result),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "usersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = EnterRoomResponse_FieldNumber_UsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EnterRoomResponse__storage_, usersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "statement",
        .dataTypeSpecific.className = GPBStringifySymbol(EnterRoomResponse_Statement),
        .number = EnterRoomResponse_FieldNumber_Statement,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EnterRoomResponse__storage_, statement),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = EnterRoomResponse_FieldNumber_Id_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EnterRoomResponse__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "likeTotal",
        .dataTypeSpecific.className = NULL,
        .number = EnterRoomResponse_FieldNumber_LikeTotal,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EnterRoomResponse__storage_, likeTotal),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EnterRoomResponse class]
                                     rootClass:[LivePackageClientRoot class]
                                          file:LivePackageClientRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EnterRoomResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\005\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EnterRoomResponse_Statement

@implementation EnterRoomResponse_Statement

@dynamic hasOnline, online;

typedef struct EnterRoomResponse_Statement__storage_ {
  uint32_t _has_storage_[1];
  int32_t online;
} EnterRoomResponse_Statement__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "online",
        .dataTypeSpecific.className = NULL,
        .number = EnterRoomResponse_Statement_FieldNumber_Online,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EnterRoomResponse_Statement__storage_, online),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EnterRoomResponse_Statement class]
                                     rootClass:[LivePackageClientRoot class]
                                          file:LivePackageClientRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EnterRoomResponse_Statement__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(EnterRoomResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LoginRequest

@implementation LoginRequest

@dynamic hasAuth, auth;
@dynamic hasNickName, nickName;
@dynamic hasHeadURL, headURL;

typedef struct LoginRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *auth;
  NSString *nickName;
  NSString *headURL;
} LoginRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "auth",
        .dataTypeSpecific.className = NULL,
        .number = LoginRequest_FieldNumber_Auth,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LoginRequest__storage_, auth),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = LoginRequest_FieldNumber_NickName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LoginRequest__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "headURL",
        .dataTypeSpecific.className = NULL,
        .number = LoginRequest_FieldNumber_HeadURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LoginRequest__storage_, headURL),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LoginRequest class]
                                     rootClass:[LivePackageClientRoot class]
                                          file:LivePackageClientRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LoginRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002H\000\003E!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LoginResponse

@implementation LoginResponse

@dynamic hasResult, result;

typedef struct LoginResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t result;
} LoginResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.className = NULL,
        .number = LoginResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LoginResponse__storage_, result),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LoginResponse class]
                                     rootClass:[LivePackageClientRoot class]
                                          file:LivePackageClientRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LoginResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TalkRequest

@implementation TalkRequest

@dynamic hasId_p, id_p;
@dynamic hasContent, content;
@dynamic hasType, type;
@dynamic hasTime, time;

typedef struct TalkRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  NSString *id_p;
  NSString *content;
  uint64_t time;
} TalkRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = TalkRequest_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TalkRequest__storage_, id_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = TalkRequest_FieldNumber_Content,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TalkRequest__storage_, content),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = TalkRequest_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TalkRequest__storage_, type),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "time",
        .dataTypeSpecific.className = NULL,
        .number = TalkRequest_FieldNumber_Time,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TalkRequest__storage_, time),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TalkRequest class]
                                     rootClass:[LivePackageClientRoot class]
                                          file:LivePackageClientRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TalkRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TalkResponse

@implementation TalkResponse

@dynamic hasId_p, id_p;

typedef struct TalkResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
} TalkResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = TalkResponse_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TalkResponse__storage_, id_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TalkResponse class]
                                     rootClass:[LivePackageClientRoot class]
                                          file:LivePackageClientRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TalkResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Broadcast

@implementation Broadcast

@dynamic hasId_p, id_p;
@dynamic hasContent, content;
@dynamic hasType, type;
@dynamic hasTime, time;
@dynamic hasUser, user;
@dynamic hasClientId, clientId;
@dynamic hasLikeTotal, likeTotal;

typedef struct Broadcast__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  NSString *id_p;
  NSString *content;
  Broadcast_User *user;
  NSString *clientId;
  uint64_t time;
  int64_t likeTotal;
} Broadcast__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = Broadcast_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Broadcast__storage_, id_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = Broadcast_FieldNumber_Content,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Broadcast__storage_, content),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = Broadcast_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Broadcast__storage_, type),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "time",
        .dataTypeSpecific.className = NULL,
        .number = Broadcast_FieldNumber_Time,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Broadcast__storage_, time),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(Broadcast_User),
        .number = Broadcast_FieldNumber_User,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Broadcast__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeGroup,
      },
      {
        .name = "clientId",
        .dataTypeSpecific.className = NULL,
        .number = Broadcast_FieldNumber_ClientId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Broadcast__storage_, clientId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "likeTotal",
        .dataTypeSpecific.className = NULL,
        .number = Broadcast_FieldNumber_LikeTotal,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Broadcast__storage_, likeTotal),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Broadcast class]
                                     rootClass:[LivePackageClientRoot class]
                                          file:LivePackageClientRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Broadcast__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\tH\000\n\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Broadcast_User

@implementation Broadcast_User

@dynamic hasUserId, userId;
@dynamic hasNickName, nickName;
@dynamic hasHeadURL, headURL;

typedef struct Broadcast_User__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSString *nickName;
  NSString *headURL;
} Broadcast_User__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = Broadcast_User_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Broadcast_User__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = Broadcast_User_FieldNumber_NickName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Broadcast_User__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "headURL",
        .dataTypeSpecific.className = NULL,
        .number = Broadcast_User_FieldNumber_HeadURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Broadcast_User__storage_, headURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Broadcast_User class]
                                     rootClass:[LivePackageClientRoot class]
                                          file:LivePackageClientRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Broadcast_User__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\006F\000\007H\000\010E!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Broadcast)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CloseRoomRequest

@implementation CloseRoomRequest

@dynamic hasRoomId, roomId;
@dynamic hasReason, reason;

typedef struct CloseRoomRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t reason;
  NSString *roomId;
} CloseRoomRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = CloseRoomRequest_FieldNumber_RoomId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CloseRoomRequest__storage_, roomId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "reason",
        .dataTypeSpecific.className = NULL,
        .number = CloseRoomRequest_FieldNumber_Reason,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CloseRoomRequest__storage_, reason),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CloseRoomRequest class]
                                     rootClass:[LivePackageClientRoot class]
                                          file:LivePackageClientRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CloseRoomRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CloseRoomResponse

@implementation CloseRoomResponse

@dynamic hasResult, result;

typedef struct CloseRoomResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t result;
} CloseRoomResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.className = NULL,
        .number = CloseRoomResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CloseRoomResponse__storage_, result),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CloseRoomResponse class]
                                     rootClass:[LivePackageClientRoot class]
                                          file:LivePackageClientRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CloseRoomResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RoomCloseBroadcast

@implementation RoomCloseBroadcast

@dynamic hasStatement, statement;
@dynamic hasReason, reason;

typedef struct RoomCloseBroadcast__storage_ {
  uint32_t _has_storage_[1];
  int32_t reason;
  RoomCloseBroadcast_Statement *statement;
} RoomCloseBroadcast__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "statement",
        .dataTypeSpecific.className = GPBStringifySymbol(RoomCloseBroadcast_Statement),
        .number = RoomCloseBroadcast_FieldNumber_Statement,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RoomCloseBroadcast__storage_, statement),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reason",
        .dataTypeSpecific.className = NULL,
        .number = RoomCloseBroadcast_FieldNumber_Reason,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RoomCloseBroadcast__storage_, reason),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RoomCloseBroadcast class]
                                     rootClass:[LivePackageClientRoot class]
                                          file:LivePackageClientRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RoomCloseBroadcast__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RoomCloseBroadcast_Statement

@implementation RoomCloseBroadcast_Statement

@dynamic hasLikeTotal, likeTotal;
@dynamic hasPostsTotal, postsTotal;
@dynamic hasOnlineTotal, onlineTotal;
@dynamic hasDuration, duration;

typedef struct RoomCloseBroadcast_Statement__storage_ {
  uint32_t _has_storage_[1];
  int32_t onlineTotal;
  int32_t duration;
  int64_t likeTotal;
  int64_t postsTotal;
} RoomCloseBroadcast_Statement__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "likeTotal",
        .dataTypeSpecific.className = NULL,
        .number = RoomCloseBroadcast_Statement_FieldNumber_LikeTotal,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RoomCloseBroadcast_Statement__storage_, likeTotal),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "postsTotal",
        .dataTypeSpecific.className = NULL,
        .number = RoomCloseBroadcast_Statement_FieldNumber_PostsTotal,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RoomCloseBroadcast_Statement__storage_, postsTotal),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "onlineTotal",
        .dataTypeSpecific.className = NULL,
        .number = RoomCloseBroadcast_Statement_FieldNumber_OnlineTotal,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RoomCloseBroadcast_Statement__storage_, onlineTotal),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "duration",
        .dataTypeSpecific.className = NULL,
        .number = RoomCloseBroadcast_Statement_FieldNumber_Duration,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RoomCloseBroadcast_Statement__storage_, duration),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RoomCloseBroadcast_Statement class]
                                     rootClass:[LivePackageClientRoot class]
                                          file:LivePackageClientRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RoomCloseBroadcast_Statement__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\t\000\002\n\000\003\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RoomCloseBroadcast)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MakeUserSilenceRequest

@implementation MakeUserSilenceRequest

@dynamic hasUserId, userId;

typedef struct MakeUserSilenceRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
} MakeUserSilenceRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = MakeUserSilenceRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MakeUserSilenceRequest__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MakeUserSilenceRequest class]
                                     rootClass:[LivePackageClientRoot class]
                                          file:LivePackageClientRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MakeUserSilenceRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
