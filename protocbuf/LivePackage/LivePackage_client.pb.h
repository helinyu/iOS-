// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: LivePackage_client.proto

#ifndef PROTOBUF_LivePackage_5fclient_2eproto__INCLUDED
#define PROTOBUF_LivePackage_5fclient_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_LivePackage_5fclient_2eproto();
void protobuf_AssignDesc_LivePackage_5fclient_2eproto();
void protobuf_ShutdownFile_LivePackage_5fclient_2eproto();

class CreateRoomRequest;
class CreateRoomResponse;
class EnterRoomRequest;
class UserInfo;
class EnterRoomResponse;
class EnterRoomResponse_Statement;
class LoginRequest;
class LoginResponse;
class TalkRequest;
class TalkResponse;
class Broadcast;
class Broadcast_User;
class CloseRoomRequest;
class CloseRoomResponse;
class RoomCloseBroadcast;
class RoomCloseBroadcast_Statement;
class MakeUserSilenceRequest;

// ===================================================================

class CreateRoomRequest : public ::google::protobuf::Message {
 public:
  CreateRoomRequest();
  virtual ~CreateRoomRequest();

  CreateRoomRequest(const CreateRoomRequest& from);

  inline CreateRoomRequest& operator=(const CreateRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoomRequest& default_instance();

  void Swap(CreateRoomRequest* other);

  // implements Message ----------------------------------------------

  CreateRoomRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateRoomRequest& from);
  void MergeFrom(const CreateRoomRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string admin = 1;
  inline bool has_admin() const;
  inline void clear_admin();
  static const int kAdminFieldNumber = 1;
  inline const ::std::string& admin() const;
  inline void set_admin(const ::std::string& value);
  inline void set_admin(const char* value);
  inline void set_admin(const char* value, size_t size);
  inline ::std::string* mutable_admin();
  inline ::std::string* release_admin();
  inline void set_allocated_admin(::std::string* admin);

  // @@protoc_insertion_point(class_scope:CreateRoomRequest)
 private:
  inline void set_has_admin();
  inline void clear_has_admin();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* admin_;
  friend void  protobuf_AddDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_AssignDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_ShutdownFile_LivePackage_5fclient_2eproto();

  void InitAsDefaultInstance();
  static CreateRoomRequest* default_instance_;
};
// -------------------------------------------------------------------

class CreateRoomResponse : public ::google::protobuf::Message {
 public:
  CreateRoomResponse();
  virtual ~CreateRoomResponse();

  CreateRoomResponse(const CreateRoomResponse& from);

  inline CreateRoomResponse& operator=(const CreateRoomResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoomResponse& default_instance();

  void Swap(CreateRoomResponse* other);

  // implements Message ----------------------------------------------

  CreateRoomResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateRoomResponse& from);
  void MergeFrom(const CreateRoomResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CreateRoomResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 result_;
  friend void  protobuf_AddDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_AssignDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_ShutdownFile_LivePackage_5fclient_2eproto();

  void InitAsDefaultInstance();
  static CreateRoomResponse* default_instance_;
};
// -------------------------------------------------------------------

class EnterRoomRequest : public ::google::protobuf::Message {
 public:
  EnterRoomRequest();
  virtual ~EnterRoomRequest();

  EnterRoomRequest(const EnterRoomRequest& from);

  inline EnterRoomRequest& operator=(const EnterRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterRoomRequest& default_instance();

  void Swap(EnterRoomRequest* other);

  // implements Message ----------------------------------------------

  EnterRoomRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterRoomRequest& from);
  void MergeFrom(const EnterRoomRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string RoomId = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // @@protoc_insertion_point(class_scope:EnterRoomRequest)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* roomid_;
  friend void  protobuf_AddDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_AssignDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_ShutdownFile_LivePackage_5fclient_2eproto();

  void InitAsDefaultInstance();
  static EnterRoomRequest* default_instance_;
};
// -------------------------------------------------------------------

class UserInfo : public ::google::protobuf::Message {
 public:
  UserInfo();
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfo& default_instance();

  void Swap(UserInfo* other);

  // implements Message ----------------------------------------------

  UserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string UserId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // optional string Nickname = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional string HeadUrl = 3;
  inline bool has_headurl() const;
  inline void clear_headurl();
  static const int kHeadUrlFieldNumber = 3;
  inline const ::std::string& headurl() const;
  inline void set_headurl(const ::std::string& value);
  inline void set_headurl(const char* value);
  inline void set_headurl(const char* value, size_t size);
  inline ::std::string* mutable_headurl();
  inline ::std::string* release_headurl();
  inline void set_allocated_headurl(::std::string* headurl);

  // @@protoc_insertion_point(class_scope:UserInfo)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_headurl();
  inline void clear_has_headurl();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* userid_;
  ::std::string* nickname_;
  ::std::string* headurl_;
  friend void  protobuf_AddDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_AssignDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_ShutdownFile_LivePackage_5fclient_2eproto();

  void InitAsDefaultInstance();
  static UserInfo* default_instance_;
};
// -------------------------------------------------------------------

class EnterRoomResponse_Statement : public ::google::protobuf::Message {
 public:
  EnterRoomResponse_Statement();
  virtual ~EnterRoomResponse_Statement();

  EnterRoomResponse_Statement(const EnterRoomResponse_Statement& from);

  inline EnterRoomResponse_Statement& operator=(const EnterRoomResponse_Statement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterRoomResponse_Statement& default_instance();

  void Swap(EnterRoomResponse_Statement* other);

  // implements Message ----------------------------------------------

  EnterRoomResponse_Statement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterRoomResponse_Statement& from);
  void MergeFrom(const EnterRoomResponse_Statement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 online = 1;
  inline bool has_online() const;
  inline void clear_online();
  static const int kOnlineFieldNumber = 1;
  inline ::google::protobuf::int32 online() const;
  inline void set_online(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:EnterRoomResponse.Statement)
 private:
  inline void set_has_online();
  inline void clear_has_online();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 online_;
  friend void  protobuf_AddDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_AssignDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_ShutdownFile_LivePackage_5fclient_2eproto();

  void InitAsDefaultInstance();
  static EnterRoomResponse_Statement* default_instance_;
};
// -------------------------------------------------------------------

class EnterRoomResponse : public ::google::protobuf::Message {
 public:
  EnterRoomResponse();
  virtual ~EnterRoomResponse();

  EnterRoomResponse(const EnterRoomResponse& from);

  inline EnterRoomResponse& operator=(const EnterRoomResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterRoomResponse& default_instance();

  void Swap(EnterRoomResponse* other);

  // implements Message ----------------------------------------------

  EnterRoomResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterRoomResponse& from);
  void MergeFrom(const EnterRoomResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef EnterRoomResponse_Statement Statement;

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // repeated .UserInfo users = 2;
  inline int users_size() const;
  inline void clear_users();
  static const int kUsersFieldNumber = 2;
  inline const ::UserInfo& users(int index) const;
  inline ::UserInfo* mutable_users(int index);
  inline ::UserInfo* add_users();
  inline const ::google::protobuf::RepeatedPtrField< ::UserInfo >&
      users() const;
  inline ::google::protobuf::RepeatedPtrField< ::UserInfo >*
      mutable_users();

  // optional .EnterRoomResponse.Statement statement = 3;
  inline bool has_statement() const;
  inline void clear_statement();
  static const int kStatementFieldNumber = 3;
  inline const ::EnterRoomResponse_Statement& statement() const;
  inline ::EnterRoomResponse_Statement* mutable_statement();
  inline ::EnterRoomResponse_Statement* release_statement();
  inline void set_allocated_statement(::EnterRoomResponse_Statement* statement);

  // optional string id = 4;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 4;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional int64 likeTotal = 5;
  inline bool has_liketotal() const;
  inline void clear_liketotal();
  static const int kLikeTotalFieldNumber = 5;
  inline ::google::protobuf::int64 liketotal() const;
  inline void set_liketotal(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:EnterRoomResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_statement();
  inline void clear_has_statement();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_liketotal();
  inline void clear_has_liketotal();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::UserInfo > users_;
  ::EnterRoomResponse_Statement* statement_;
  ::std::string* id_;
  ::google::protobuf::int64 liketotal_;
  ::google::protobuf::int32 result_;
  friend void  protobuf_AddDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_AssignDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_ShutdownFile_LivePackage_5fclient_2eproto();

  void InitAsDefaultInstance();
  static EnterRoomResponse* default_instance_;
};
// -------------------------------------------------------------------

class LoginRequest : public ::google::protobuf::Message {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();

  void Swap(LoginRequest* other);

  // implements Message ----------------------------------------------

  LoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string auth = 1;
  inline bool has_auth() const;
  inline void clear_auth();
  static const int kAuthFieldNumber = 1;
  inline const ::std::string& auth() const;
  inline void set_auth(const ::std::string& value);
  inline void set_auth(const char* value);
  inline void set_auth(const char* value, size_t size);
  inline ::std::string* mutable_auth();
  inline ::std::string* release_auth();
  inline void set_allocated_auth(::std::string* auth);

  // required string NickName = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // required string HeadUrl = 3;
  inline bool has_headurl() const;
  inline void clear_headurl();
  static const int kHeadUrlFieldNumber = 3;
  inline const ::std::string& headurl() const;
  inline void set_headurl(const ::std::string& value);
  inline void set_headurl(const char* value);
  inline void set_headurl(const char* value, size_t size);
  inline ::std::string* mutable_headurl();
  inline ::std::string* release_headurl();
  inline void set_allocated_headurl(::std::string* headurl);

  // @@protoc_insertion_point(class_scope:LoginRequest)
 private:
  inline void set_has_auth();
  inline void clear_has_auth();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_headurl();
  inline void clear_has_headurl();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* auth_;
  ::std::string* nickname_;
  ::std::string* headurl_;
  friend void  protobuf_AddDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_AssignDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_ShutdownFile_LivePackage_5fclient_2eproto();

  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::Message {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResponse& default_instance();

  void Swap(LoginResponse* other);

  // implements Message ----------------------------------------------

  LoginResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:LoginResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 result_;
  friend void  protobuf_AddDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_AssignDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_ShutdownFile_LivePackage_5fclient_2eproto();

  void InitAsDefaultInstance();
  static LoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class TalkRequest : public ::google::protobuf::Message {
 public:
  TalkRequest();
  virtual ~TalkRequest();

  TalkRequest(const TalkRequest& from);

  inline TalkRequest& operator=(const TalkRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TalkRequest& default_instance();

  void Swap(TalkRequest* other);

  // implements Message ----------------------------------------------

  TalkRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TalkRequest& from);
  void MergeFrom(const TalkRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // required int32 type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required uint64 time = 5;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 5;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:TalkRequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::std::string* content_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::int32 type_;
  friend void  protobuf_AddDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_AssignDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_ShutdownFile_LivePackage_5fclient_2eproto();

  void InitAsDefaultInstance();
  static TalkRequest* default_instance_;
};
// -------------------------------------------------------------------

class TalkResponse : public ::google::protobuf::Message {
 public:
  TalkResponse();
  virtual ~TalkResponse();

  TalkResponse(const TalkResponse& from);

  inline TalkResponse& operator=(const TalkResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TalkResponse& default_instance();

  void Swap(TalkResponse* other);

  // implements Message ----------------------------------------------

  TalkResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TalkResponse& from);
  void MergeFrom(const TalkResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:TalkResponse)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  friend void  protobuf_AddDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_AssignDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_ShutdownFile_LivePackage_5fclient_2eproto();

  void InitAsDefaultInstance();
  static TalkResponse* default_instance_;
};
// -------------------------------------------------------------------

class Broadcast_User : public ::google::protobuf::Message {
 public:
  Broadcast_User();
  virtual ~Broadcast_User();

  Broadcast_User(const Broadcast_User& from);

  inline Broadcast_User& operator=(const Broadcast_User& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Broadcast_User& default_instance();

  void Swap(Broadcast_User* other);

  // implements Message ----------------------------------------------

  Broadcast_User* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Broadcast_User& from);
  void MergeFrom(const Broadcast_User& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string UserId = 6;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 6;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // optional string NickName = 7;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 7;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional string HeadUrl = 8;
  inline bool has_headurl() const;
  inline void clear_headurl();
  static const int kHeadUrlFieldNumber = 8;
  inline const ::std::string& headurl() const;
  inline void set_headurl(const ::std::string& value);
  inline void set_headurl(const char* value);
  inline void set_headurl(const char* value, size_t size);
  inline ::std::string* mutable_headurl();
  inline ::std::string* release_headurl();
  inline void set_allocated_headurl(::std::string* headurl);

  // @@protoc_insertion_point(class_scope:Broadcast.User)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_headurl();
  inline void clear_has_headurl();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* userid_;
  ::std::string* nickname_;
  ::std::string* headurl_;
  friend void  protobuf_AddDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_AssignDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_ShutdownFile_LivePackage_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Broadcast_User* default_instance_;
};
// -------------------------------------------------------------------

class Broadcast : public ::google::protobuf::Message {
 public:
  Broadcast();
  virtual ~Broadcast();

  Broadcast(const Broadcast& from);

  inline Broadcast& operator=(const Broadcast& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Broadcast& default_instance();

  void Swap(Broadcast* other);

  // implements Message ----------------------------------------------

  Broadcast* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Broadcast& from);
  void MergeFrom(const Broadcast& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Broadcast_User User;

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // required int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required uint64 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // optional group User = 5 {
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 5;
  inline const ::Broadcast_User& user() const;
  inline ::Broadcast_User* mutable_user();
  inline ::Broadcast_User* release_user();
  inline void set_allocated_user(::Broadcast_User* user);

  // optional string ClientId = 9;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 9;
  inline const ::std::string& clientid() const;
  inline void set_clientid(const ::std::string& value);
  inline void set_clientid(const char* value);
  inline void set_clientid(const char* value, size_t size);
  inline ::std::string* mutable_clientid();
  inline ::std::string* release_clientid();
  inline void set_allocated_clientid(::std::string* clientid);

  // optional int64 likeTotal = 10;
  inline bool has_liketotal() const;
  inline void clear_liketotal();
  static const int kLikeTotalFieldNumber = 10;
  inline ::google::protobuf::int64 liketotal() const;
  inline void set_liketotal(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Broadcast)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_liketotal();
  inline void clear_has_liketotal();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::std::string* content_;
  ::google::protobuf::uint64 time_;
  ::Broadcast_User* user_;
  ::std::string* clientid_;
  ::google::protobuf::int64 liketotal_;
  ::google::protobuf::int32 type_;
  friend void  protobuf_AddDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_AssignDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_ShutdownFile_LivePackage_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Broadcast* default_instance_;
};
// -------------------------------------------------------------------

class CloseRoomRequest : public ::google::protobuf::Message {
 public:
  CloseRoomRequest();
  virtual ~CloseRoomRequest();

  CloseRoomRequest(const CloseRoomRequest& from);

  inline CloseRoomRequest& operator=(const CloseRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseRoomRequest& default_instance();

  void Swap(CloseRoomRequest* other);

  // implements Message ----------------------------------------------

  CloseRoomRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CloseRoomRequest& from);
  void MergeFrom(const CloseRoomRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string RoomId = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // required int32 reason = 2;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 2;
  inline ::google::protobuf::int32 reason() const;
  inline void set_reason(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CloseRoomRequest)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_reason();
  inline void clear_has_reason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* roomid_;
  ::google::protobuf::int32 reason_;
  friend void  protobuf_AddDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_AssignDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_ShutdownFile_LivePackage_5fclient_2eproto();

  void InitAsDefaultInstance();
  static CloseRoomRequest* default_instance_;
};
// -------------------------------------------------------------------

class CloseRoomResponse : public ::google::protobuf::Message {
 public:
  CloseRoomResponse();
  virtual ~CloseRoomResponse();

  CloseRoomResponse(const CloseRoomResponse& from);

  inline CloseRoomResponse& operator=(const CloseRoomResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseRoomResponse& default_instance();

  void Swap(CloseRoomResponse* other);

  // implements Message ----------------------------------------------

  CloseRoomResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CloseRoomResponse& from);
  void MergeFrom(const CloseRoomResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CloseRoomResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 result_;
  friend void  protobuf_AddDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_AssignDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_ShutdownFile_LivePackage_5fclient_2eproto();

  void InitAsDefaultInstance();
  static CloseRoomResponse* default_instance_;
};
// -------------------------------------------------------------------

class RoomCloseBroadcast_Statement : public ::google::protobuf::Message {
 public:
  RoomCloseBroadcast_Statement();
  virtual ~RoomCloseBroadcast_Statement();

  RoomCloseBroadcast_Statement(const RoomCloseBroadcast_Statement& from);

  inline RoomCloseBroadcast_Statement& operator=(const RoomCloseBroadcast_Statement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomCloseBroadcast_Statement& default_instance();

  void Swap(RoomCloseBroadcast_Statement* other);

  // implements Message ----------------------------------------------

  RoomCloseBroadcast_Statement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomCloseBroadcast_Statement& from);
  void MergeFrom(const RoomCloseBroadcast_Statement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 likeTotal = 1;
  inline bool has_liketotal() const;
  inline void clear_liketotal();
  static const int kLikeTotalFieldNumber = 1;
  inline ::google::protobuf::int64 liketotal() const;
  inline void set_liketotal(::google::protobuf::int64 value);

  // required int64 postsTotal = 2;
  inline bool has_poststotal() const;
  inline void clear_poststotal();
  static const int kPostsTotalFieldNumber = 2;
  inline ::google::protobuf::int64 poststotal() const;
  inline void set_poststotal(::google::protobuf::int64 value);

  // required int32 onlineTotal = 3;
  inline bool has_onlinetotal() const;
  inline void clear_onlinetotal();
  static const int kOnlineTotalFieldNumber = 3;
  inline ::google::protobuf::int32 onlinetotal() const;
  inline void set_onlinetotal(::google::protobuf::int32 value);

  // required int32 duration = 4;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 4;
  inline ::google::protobuf::int32 duration() const;
  inline void set_duration(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RoomCloseBroadcast.Statement)
 private:
  inline void set_has_liketotal();
  inline void clear_has_liketotal();
  inline void set_has_poststotal();
  inline void clear_has_poststotal();
  inline void set_has_onlinetotal();
  inline void clear_has_onlinetotal();
  inline void set_has_duration();
  inline void clear_has_duration();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 liketotal_;
  ::google::protobuf::int64 poststotal_;
  ::google::protobuf::int32 onlinetotal_;
  ::google::protobuf::int32 duration_;
  friend void  protobuf_AddDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_AssignDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_ShutdownFile_LivePackage_5fclient_2eproto();

  void InitAsDefaultInstance();
  static RoomCloseBroadcast_Statement* default_instance_;
};
// -------------------------------------------------------------------

class RoomCloseBroadcast : public ::google::protobuf::Message {
 public:
  RoomCloseBroadcast();
  virtual ~RoomCloseBroadcast();

  RoomCloseBroadcast(const RoomCloseBroadcast& from);

  inline RoomCloseBroadcast& operator=(const RoomCloseBroadcast& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomCloseBroadcast& default_instance();

  void Swap(RoomCloseBroadcast* other);

  // implements Message ----------------------------------------------

  RoomCloseBroadcast* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomCloseBroadcast& from);
  void MergeFrom(const RoomCloseBroadcast& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RoomCloseBroadcast_Statement Statement;

  // accessors -------------------------------------------------------

  // required .RoomCloseBroadcast.Statement statement = 1;
  inline bool has_statement() const;
  inline void clear_statement();
  static const int kStatementFieldNumber = 1;
  inline const ::RoomCloseBroadcast_Statement& statement() const;
  inline ::RoomCloseBroadcast_Statement* mutable_statement();
  inline ::RoomCloseBroadcast_Statement* release_statement();
  inline void set_allocated_statement(::RoomCloseBroadcast_Statement* statement);

  // required int32 reason = 2;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 2;
  inline ::google::protobuf::int32 reason() const;
  inline void set_reason(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RoomCloseBroadcast)
 private:
  inline void set_has_statement();
  inline void clear_has_statement();
  inline void set_has_reason();
  inline void clear_has_reason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::RoomCloseBroadcast_Statement* statement_;
  ::google::protobuf::int32 reason_;
  friend void  protobuf_AddDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_AssignDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_ShutdownFile_LivePackage_5fclient_2eproto();

  void InitAsDefaultInstance();
  static RoomCloseBroadcast* default_instance_;
};
// -------------------------------------------------------------------

class MakeUserSilenceRequest : public ::google::protobuf::Message {
 public:
  MakeUserSilenceRequest();
  virtual ~MakeUserSilenceRequest();

  MakeUserSilenceRequest(const MakeUserSilenceRequest& from);

  inline MakeUserSilenceRequest& operator=(const MakeUserSilenceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MakeUserSilenceRequest& default_instance();

  void Swap(MakeUserSilenceRequest* other);

  // implements Message ----------------------------------------------

  MakeUserSilenceRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MakeUserSilenceRequest& from);
  void MergeFrom(const MakeUserSilenceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string UserId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // @@protoc_insertion_point(class_scope:MakeUserSilenceRequest)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* userid_;
  friend void  protobuf_AddDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_AssignDesc_LivePackage_5fclient_2eproto();
  friend void protobuf_ShutdownFile_LivePackage_5fclient_2eproto();

  void InitAsDefaultInstance();
  static MakeUserSilenceRequest* default_instance_;
};
// ===================================================================


// ===================================================================

// CreateRoomRequest

// required string admin = 1;
inline bool CreateRoomRequest::has_admin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoomRequest::set_has_admin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoomRequest::clear_has_admin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoomRequest::clear_admin() {
  if (admin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    admin_->clear();
  }
  clear_has_admin();
}
inline const ::std::string& CreateRoomRequest::admin() const {
  // @@protoc_insertion_point(field_get:CreateRoomRequest.admin)
  return *admin_;
}
inline void CreateRoomRequest::set_admin(const ::std::string& value) {
  set_has_admin();
  if (admin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    admin_ = new ::std::string;
  }
  admin_->assign(value);
  // @@protoc_insertion_point(field_set:CreateRoomRequest.admin)
}
inline void CreateRoomRequest::set_admin(const char* value) {
  set_has_admin();
  if (admin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    admin_ = new ::std::string;
  }
  admin_->assign(value);
  // @@protoc_insertion_point(field_set_char:CreateRoomRequest.admin)
}
inline void CreateRoomRequest::set_admin(const char* value, size_t size) {
  set_has_admin();
  if (admin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    admin_ = new ::std::string;
  }
  admin_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CreateRoomRequest.admin)
}
inline ::std::string* CreateRoomRequest::mutable_admin() {
  set_has_admin();
  if (admin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    admin_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CreateRoomRequest.admin)
  return admin_;
}
inline ::std::string* CreateRoomRequest::release_admin() {
  clear_has_admin();
  if (admin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = admin_;
    admin_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateRoomRequest::set_allocated_admin(::std::string* admin) {
  if (admin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete admin_;
  }
  if (admin) {
    set_has_admin();
    admin_ = admin;
  } else {
    clear_has_admin();
    admin_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CreateRoomRequest.admin)
}

// -------------------------------------------------------------------

// CreateRoomResponse

// required int32 result = 1;
inline bool CreateRoomResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoomResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoomResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoomResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 CreateRoomResponse::result() const {
  // @@protoc_insertion_point(field_get:CreateRoomResponse.result)
  return result_;
}
inline void CreateRoomResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CreateRoomResponse.result)
}

// -------------------------------------------------------------------

// EnterRoomRequest

// required string RoomId = 1;
inline bool EnterRoomRequest::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterRoomRequest::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterRoomRequest::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterRoomRequest::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& EnterRoomRequest::roomid() const {
  // @@protoc_insertion_point(field_get:EnterRoomRequest.RoomId)
  return *roomid_;
}
inline void EnterRoomRequest::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
  // @@protoc_insertion_point(field_set:EnterRoomRequest.RoomId)
}
inline void EnterRoomRequest::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
  // @@protoc_insertion_point(field_set_char:EnterRoomRequest.RoomId)
}
inline void EnterRoomRequest::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:EnterRoomRequest.RoomId)
}
inline ::std::string* EnterRoomRequest::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:EnterRoomRequest.RoomId)
  return roomid_;
}
inline ::std::string* EnterRoomRequest::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EnterRoomRequest::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:EnterRoomRequest.RoomId)
}

// -------------------------------------------------------------------

// UserInfo

// required string UserId = 1;
inline bool UserInfo::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_userid() {
  if (userid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& UserInfo::userid() const {
  // @@protoc_insertion_point(field_get:UserInfo.UserId)
  return *userid_;
}
inline void UserInfo::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
  // @@protoc_insertion_point(field_set:UserInfo.UserId)
}
inline void UserInfo::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
  // @@protoc_insertion_point(field_set_char:UserInfo.UserId)
}
inline void UserInfo::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:UserInfo.UserId)
}
inline ::std::string* UserInfo::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:UserInfo.UserId)
  return userid_;
}
inline ::std::string* UserInfo::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:UserInfo.UserId)
}

// optional string Nickname = 2;
inline bool UserInfo::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& UserInfo::nickname() const {
  // @@protoc_insertion_point(field_get:UserInfo.Nickname)
  return *nickname_;
}
inline void UserInfo::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:UserInfo.Nickname)
}
inline void UserInfo::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:UserInfo.Nickname)
}
inline void UserInfo::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:UserInfo.Nickname)
}
inline ::std::string* UserInfo::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:UserInfo.Nickname)
  return nickname_;
}
inline ::std::string* UserInfo::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:UserInfo.Nickname)
}

// optional string HeadUrl = 3;
inline bool UserInfo::has_headurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfo::set_has_headurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfo::clear_has_headurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfo::clear_headurl() {
  if (headurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headurl_->clear();
  }
  clear_has_headurl();
}
inline const ::std::string& UserInfo::headurl() const {
  // @@protoc_insertion_point(field_get:UserInfo.HeadUrl)
  return *headurl_;
}
inline void UserInfo::set_headurl(const ::std::string& value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
  // @@protoc_insertion_point(field_set:UserInfo.HeadUrl)
}
inline void UserInfo::set_headurl(const char* value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
  // @@protoc_insertion_point(field_set_char:UserInfo.HeadUrl)
}
inline void UserInfo::set_headurl(const char* value, size_t size) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:UserInfo.HeadUrl)
}
inline ::std::string* UserInfo::mutable_headurl() {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headurl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:UserInfo.HeadUrl)
  return headurl_;
}
inline ::std::string* UserInfo::release_headurl() {
  clear_has_headurl();
  if (headurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = headurl_;
    headurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_headurl(::std::string* headurl) {
  if (headurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete headurl_;
  }
  if (headurl) {
    set_has_headurl();
    headurl_ = headurl;
  } else {
    clear_has_headurl();
    headurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:UserInfo.HeadUrl)
}

// -------------------------------------------------------------------

// EnterRoomResponse_Statement

// optional int32 online = 1;
inline bool EnterRoomResponse_Statement::has_online() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterRoomResponse_Statement::set_has_online() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterRoomResponse_Statement::clear_has_online() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterRoomResponse_Statement::clear_online() {
  online_ = 0;
  clear_has_online();
}
inline ::google::protobuf::int32 EnterRoomResponse_Statement::online() const {
  // @@protoc_insertion_point(field_get:EnterRoomResponse.Statement.online)
  return online_;
}
inline void EnterRoomResponse_Statement::set_online(::google::protobuf::int32 value) {
  set_has_online();
  online_ = value;
  // @@protoc_insertion_point(field_set:EnterRoomResponse.Statement.online)
}

// -------------------------------------------------------------------

// EnterRoomResponse

// required int32 result = 1;
inline bool EnterRoomResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterRoomResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterRoomResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterRoomResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 EnterRoomResponse::result() const {
  // @@protoc_insertion_point(field_get:EnterRoomResponse.result)
  return result_;
}
inline void EnterRoomResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:EnterRoomResponse.result)
}

// repeated .UserInfo users = 2;
inline int EnterRoomResponse::users_size() const {
  return users_.size();
}
inline void EnterRoomResponse::clear_users() {
  users_.Clear();
}
inline const ::UserInfo& EnterRoomResponse::users(int index) const {
  // @@protoc_insertion_point(field_get:EnterRoomResponse.users)
  return users_.Get(index);
}
inline ::UserInfo* EnterRoomResponse::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:EnterRoomResponse.users)
  return users_.Mutable(index);
}
inline ::UserInfo* EnterRoomResponse::add_users() {
  // @@protoc_insertion_point(field_add:EnterRoomResponse.users)
  return users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::UserInfo >&
EnterRoomResponse::users() const {
  // @@protoc_insertion_point(field_list:EnterRoomResponse.users)
  return users_;
}
inline ::google::protobuf::RepeatedPtrField< ::UserInfo >*
EnterRoomResponse::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:EnterRoomResponse.users)
  return &users_;
}

// optional .EnterRoomResponse.Statement statement = 3;
inline bool EnterRoomResponse::has_statement() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnterRoomResponse::set_has_statement() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnterRoomResponse::clear_has_statement() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnterRoomResponse::clear_statement() {
  if (statement_ != NULL) statement_->::EnterRoomResponse_Statement::Clear();
  clear_has_statement();
}
inline const ::EnterRoomResponse_Statement& EnterRoomResponse::statement() const {
  // @@protoc_insertion_point(field_get:EnterRoomResponse.statement)
  return statement_ != NULL ? *statement_ : *default_instance_->statement_;
}
inline ::EnterRoomResponse_Statement* EnterRoomResponse::mutable_statement() {
  set_has_statement();
  if (statement_ == NULL) statement_ = new ::EnterRoomResponse_Statement;
  // @@protoc_insertion_point(field_mutable:EnterRoomResponse.statement)
  return statement_;
}
inline ::EnterRoomResponse_Statement* EnterRoomResponse::release_statement() {
  clear_has_statement();
  ::EnterRoomResponse_Statement* temp = statement_;
  statement_ = NULL;
  return temp;
}
inline void EnterRoomResponse::set_allocated_statement(::EnterRoomResponse_Statement* statement) {
  delete statement_;
  statement_ = statement;
  if (statement) {
    set_has_statement();
  } else {
    clear_has_statement();
  }
  // @@protoc_insertion_point(field_set_allocated:EnterRoomResponse.statement)
}

// optional string id = 4;
inline bool EnterRoomResponse::has_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EnterRoomResponse::set_has_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EnterRoomResponse::clear_has_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EnterRoomResponse::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& EnterRoomResponse::id() const {
  // @@protoc_insertion_point(field_get:EnterRoomResponse.id)
  return *id_;
}
inline void EnterRoomResponse::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:EnterRoomResponse.id)
}
inline void EnterRoomResponse::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:EnterRoomResponse.id)
}
inline void EnterRoomResponse::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:EnterRoomResponse.id)
}
inline ::std::string* EnterRoomResponse::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:EnterRoomResponse.id)
  return id_;
}
inline ::std::string* EnterRoomResponse::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EnterRoomResponse::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:EnterRoomResponse.id)
}

// optional int64 likeTotal = 5;
inline bool EnterRoomResponse::has_liketotal() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EnterRoomResponse::set_has_liketotal() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EnterRoomResponse::clear_has_liketotal() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EnterRoomResponse::clear_liketotal() {
  liketotal_ = GOOGLE_LONGLONG(0);
  clear_has_liketotal();
}
inline ::google::protobuf::int64 EnterRoomResponse::liketotal() const {
  // @@protoc_insertion_point(field_get:EnterRoomResponse.likeTotal)
  return liketotal_;
}
inline void EnterRoomResponse::set_liketotal(::google::protobuf::int64 value) {
  set_has_liketotal();
  liketotal_ = value;
  // @@protoc_insertion_point(field_set:EnterRoomResponse.likeTotal)
}

// -------------------------------------------------------------------

// LoginRequest

// required string auth = 1;
inline bool LoginRequest::has_auth() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_auth() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_auth() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_auth() {
  if (auth_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_->clear();
  }
  clear_has_auth();
}
inline const ::std::string& LoginRequest::auth() const {
  // @@protoc_insertion_point(field_get:LoginRequest.auth)
  return *auth_;
}
inline void LoginRequest::set_auth(const ::std::string& value) {
  set_has_auth();
  if (auth_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_ = new ::std::string;
  }
  auth_->assign(value);
  // @@protoc_insertion_point(field_set:LoginRequest.auth)
}
inline void LoginRequest::set_auth(const char* value) {
  set_has_auth();
  if (auth_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_ = new ::std::string;
  }
  auth_->assign(value);
  // @@protoc_insertion_point(field_set_char:LoginRequest.auth)
}
inline void LoginRequest::set_auth(const char* value, size_t size) {
  set_has_auth();
  if (auth_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_ = new ::std::string;
  }
  auth_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:LoginRequest.auth)
}
inline ::std::string* LoginRequest::mutable_auth() {
  set_has_auth();
  if (auth_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:LoginRequest.auth)
  return auth_;
}
inline ::std::string* LoginRequest::release_auth() {
  clear_has_auth();
  if (auth_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = auth_;
    auth_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginRequest::set_allocated_auth(::std::string* auth) {
  if (auth_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete auth_;
  }
  if (auth) {
    set_has_auth();
    auth_ = auth;
  } else {
    clear_has_auth();
    auth_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:LoginRequest.auth)
}

// required string NickName = 2;
inline bool LoginRequest::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& LoginRequest::nickname() const {
  // @@protoc_insertion_point(field_get:LoginRequest.NickName)
  return *nickname_;
}
inline void LoginRequest::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:LoginRequest.NickName)
}
inline void LoginRequest::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:LoginRequest.NickName)
}
inline void LoginRequest::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:LoginRequest.NickName)
}
inline ::std::string* LoginRequest::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:LoginRequest.NickName)
  return nickname_;
}
inline ::std::string* LoginRequest::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginRequest::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:LoginRequest.NickName)
}

// required string HeadUrl = 3;
inline bool LoginRequest::has_headurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginRequest::set_has_headurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginRequest::clear_has_headurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginRequest::clear_headurl() {
  if (headurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headurl_->clear();
  }
  clear_has_headurl();
}
inline const ::std::string& LoginRequest::headurl() const {
  // @@protoc_insertion_point(field_get:LoginRequest.HeadUrl)
  return *headurl_;
}
inline void LoginRequest::set_headurl(const ::std::string& value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
  // @@protoc_insertion_point(field_set:LoginRequest.HeadUrl)
}
inline void LoginRequest::set_headurl(const char* value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
  // @@protoc_insertion_point(field_set_char:LoginRequest.HeadUrl)
}
inline void LoginRequest::set_headurl(const char* value, size_t size) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:LoginRequest.HeadUrl)
}
inline ::std::string* LoginRequest::mutable_headurl() {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headurl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:LoginRequest.HeadUrl)
  return headurl_;
}
inline ::std::string* LoginRequest::release_headurl() {
  clear_has_headurl();
  if (headurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = headurl_;
    headurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginRequest::set_allocated_headurl(::std::string* headurl) {
  if (headurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete headurl_;
  }
  if (headurl) {
    set_has_headurl();
    headurl_ = headurl;
  } else {
    clear_has_headurl();
    headurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:LoginRequest.HeadUrl)
}

// -------------------------------------------------------------------

// LoginResponse

// required int32 result = 1;
inline bool LoginResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 LoginResponse::result() const {
  // @@protoc_insertion_point(field_get:LoginResponse.result)
  return result_;
}
inline void LoginResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:LoginResponse.result)
}

// -------------------------------------------------------------------

// TalkRequest

// required string id = 1;
inline bool TalkRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TalkRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TalkRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TalkRequest::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& TalkRequest::id() const {
  // @@protoc_insertion_point(field_get:TalkRequest.id)
  return *id_;
}
inline void TalkRequest::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:TalkRequest.id)
}
inline void TalkRequest::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:TalkRequest.id)
}
inline void TalkRequest::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TalkRequest.id)
}
inline ::std::string* TalkRequest::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TalkRequest.id)
  return id_;
}
inline ::std::string* TalkRequest::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TalkRequest::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TalkRequest.id)
}

// required string content = 3;
inline bool TalkRequest::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TalkRequest::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TalkRequest::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TalkRequest::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& TalkRequest::content() const {
  // @@protoc_insertion_point(field_get:TalkRequest.content)
  return *content_;
}
inline void TalkRequest::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:TalkRequest.content)
}
inline void TalkRequest::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:TalkRequest.content)
}
inline void TalkRequest::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TalkRequest.content)
}
inline ::std::string* TalkRequest::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TalkRequest.content)
  return content_;
}
inline ::std::string* TalkRequest::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TalkRequest::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TalkRequest.content)
}

// required int32 type = 4;
inline bool TalkRequest::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TalkRequest::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TalkRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TalkRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 TalkRequest::type() const {
  // @@protoc_insertion_point(field_get:TalkRequest.type)
  return type_;
}
inline void TalkRequest::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:TalkRequest.type)
}

// required uint64 time = 5;
inline bool TalkRequest::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TalkRequest::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TalkRequest::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TalkRequest::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 TalkRequest::time() const {
  // @@protoc_insertion_point(field_get:TalkRequest.time)
  return time_;
}
inline void TalkRequest::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:TalkRequest.time)
}

// -------------------------------------------------------------------

// TalkResponse

// required string id = 1;
inline bool TalkResponse::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TalkResponse::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TalkResponse::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TalkResponse::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& TalkResponse::id() const {
  // @@protoc_insertion_point(field_get:TalkResponse.id)
  return *id_;
}
inline void TalkResponse::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:TalkResponse.id)
}
inline void TalkResponse::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:TalkResponse.id)
}
inline void TalkResponse::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TalkResponse.id)
}
inline ::std::string* TalkResponse::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TalkResponse.id)
  return id_;
}
inline ::std::string* TalkResponse::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TalkResponse::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TalkResponse.id)
}

// -------------------------------------------------------------------

// Broadcast_User

// required string UserId = 6;
inline bool Broadcast_User::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Broadcast_User::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Broadcast_User::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Broadcast_User::clear_userid() {
  if (userid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& Broadcast_User::userid() const {
  // @@protoc_insertion_point(field_get:Broadcast.User.UserId)
  return *userid_;
}
inline void Broadcast_User::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
  // @@protoc_insertion_point(field_set:Broadcast.User.UserId)
}
inline void Broadcast_User::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Broadcast.User.UserId)
}
inline void Broadcast_User::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Broadcast.User.UserId)
}
inline ::std::string* Broadcast_User::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Broadcast.User.UserId)
  return userid_;
}
inline ::std::string* Broadcast_User::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Broadcast_User::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Broadcast.User.UserId)
}

// optional string NickName = 7;
inline bool Broadcast_User::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Broadcast_User::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Broadcast_User::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Broadcast_User::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& Broadcast_User::nickname() const {
  // @@protoc_insertion_point(field_get:Broadcast.User.NickName)
  return *nickname_;
}
inline void Broadcast_User::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:Broadcast.User.NickName)
}
inline void Broadcast_User::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Broadcast.User.NickName)
}
inline void Broadcast_User::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Broadcast.User.NickName)
}
inline ::std::string* Broadcast_User::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Broadcast.User.NickName)
  return nickname_;
}
inline ::std::string* Broadcast_User::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Broadcast_User::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Broadcast.User.NickName)
}

// optional string HeadUrl = 8;
inline bool Broadcast_User::has_headurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Broadcast_User::set_has_headurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Broadcast_User::clear_has_headurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Broadcast_User::clear_headurl() {
  if (headurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headurl_->clear();
  }
  clear_has_headurl();
}
inline const ::std::string& Broadcast_User::headurl() const {
  // @@protoc_insertion_point(field_get:Broadcast.User.HeadUrl)
  return *headurl_;
}
inline void Broadcast_User::set_headurl(const ::std::string& value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
  // @@protoc_insertion_point(field_set:Broadcast.User.HeadUrl)
}
inline void Broadcast_User::set_headurl(const char* value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
  // @@protoc_insertion_point(field_set_char:Broadcast.User.HeadUrl)
}
inline void Broadcast_User::set_headurl(const char* value, size_t size) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Broadcast.User.HeadUrl)
}
inline ::std::string* Broadcast_User::mutable_headurl() {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headurl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Broadcast.User.HeadUrl)
  return headurl_;
}
inline ::std::string* Broadcast_User::release_headurl() {
  clear_has_headurl();
  if (headurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = headurl_;
    headurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Broadcast_User::set_allocated_headurl(::std::string* headurl) {
  if (headurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete headurl_;
  }
  if (headurl) {
    set_has_headurl();
    headurl_ = headurl;
  } else {
    clear_has_headurl();
    headurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Broadcast.User.HeadUrl)
}

// -------------------------------------------------------------------

// Broadcast

// required string id = 1;
inline bool Broadcast::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Broadcast::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Broadcast::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Broadcast::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Broadcast::id() const {
  // @@protoc_insertion_point(field_get:Broadcast.id)
  return *id_;
}
inline void Broadcast::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:Broadcast.id)
}
inline void Broadcast::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:Broadcast.id)
}
inline void Broadcast::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Broadcast.id)
}
inline ::std::string* Broadcast::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Broadcast.id)
  return id_;
}
inline ::std::string* Broadcast::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Broadcast::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Broadcast.id)
}

// required string content = 2;
inline bool Broadcast::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Broadcast::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Broadcast::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Broadcast::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& Broadcast::content() const {
  // @@protoc_insertion_point(field_get:Broadcast.content)
  return *content_;
}
inline void Broadcast::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:Broadcast.content)
}
inline void Broadcast::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:Broadcast.content)
}
inline void Broadcast::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Broadcast.content)
}
inline ::std::string* Broadcast::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Broadcast.content)
  return content_;
}
inline ::std::string* Broadcast::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Broadcast::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Broadcast.content)
}

// required int32 type = 3;
inline bool Broadcast::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Broadcast::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Broadcast::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Broadcast::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Broadcast::type() const {
  // @@protoc_insertion_point(field_get:Broadcast.type)
  return type_;
}
inline void Broadcast::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Broadcast.type)
}

// required uint64 time = 4;
inline bool Broadcast::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Broadcast::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Broadcast::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Broadcast::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 Broadcast::time() const {
  // @@protoc_insertion_point(field_get:Broadcast.time)
  return time_;
}
inline void Broadcast::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:Broadcast.time)
}

// optional group User = 5 {
inline bool Broadcast::has_user() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Broadcast::set_has_user() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Broadcast::clear_has_user() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Broadcast::clear_user() {
  if (user_ != NULL) user_->::Broadcast_User::Clear();
  clear_has_user();
}
inline const ::Broadcast_User& Broadcast::user() const {
  // @@protoc_insertion_point(field_get:Broadcast.user)
  return user_ != NULL ? *user_ : *default_instance_->user_;
}
inline ::Broadcast_User* Broadcast::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::Broadcast_User;
  // @@protoc_insertion_point(field_mutable:Broadcast.user)
  return user_;
}
inline ::Broadcast_User* Broadcast::release_user() {
  clear_has_user();
  ::Broadcast_User* temp = user_;
  user_ = NULL;
  return temp;
}
inline void Broadcast::set_allocated_user(::Broadcast_User* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
  // @@protoc_insertion_point(field_set_allocated:Broadcast.user)
}

// optional string ClientId = 9;
inline bool Broadcast::has_clientid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Broadcast::set_has_clientid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Broadcast::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Broadcast::clear_clientid() {
  if (clientid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientid_->clear();
  }
  clear_has_clientid();
}
inline const ::std::string& Broadcast::clientid() const {
  // @@protoc_insertion_point(field_get:Broadcast.ClientId)
  return *clientid_;
}
inline void Broadcast::set_clientid(const ::std::string& value) {
  set_has_clientid();
  if (clientid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientid_ = new ::std::string;
  }
  clientid_->assign(value);
  // @@protoc_insertion_point(field_set:Broadcast.ClientId)
}
inline void Broadcast::set_clientid(const char* value) {
  set_has_clientid();
  if (clientid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientid_ = new ::std::string;
  }
  clientid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Broadcast.ClientId)
}
inline void Broadcast::set_clientid(const char* value, size_t size) {
  set_has_clientid();
  if (clientid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientid_ = new ::std::string;
  }
  clientid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Broadcast.ClientId)
}
inline ::std::string* Broadcast::mutable_clientid() {
  set_has_clientid();
  if (clientid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Broadcast.ClientId)
  return clientid_;
}
inline ::std::string* Broadcast::release_clientid() {
  clear_has_clientid();
  if (clientid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = clientid_;
    clientid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Broadcast::set_allocated_clientid(::std::string* clientid) {
  if (clientid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete clientid_;
  }
  if (clientid) {
    set_has_clientid();
    clientid_ = clientid;
  } else {
    clear_has_clientid();
    clientid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Broadcast.ClientId)
}

// optional int64 likeTotal = 10;
inline bool Broadcast::has_liketotal() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Broadcast::set_has_liketotal() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Broadcast::clear_has_liketotal() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Broadcast::clear_liketotal() {
  liketotal_ = GOOGLE_LONGLONG(0);
  clear_has_liketotal();
}
inline ::google::protobuf::int64 Broadcast::liketotal() const {
  // @@protoc_insertion_point(field_get:Broadcast.likeTotal)
  return liketotal_;
}
inline void Broadcast::set_liketotal(::google::protobuf::int64 value) {
  set_has_liketotal();
  liketotal_ = value;
  // @@protoc_insertion_point(field_set:Broadcast.likeTotal)
}

// -------------------------------------------------------------------

// CloseRoomRequest

// required string RoomId = 1;
inline bool CloseRoomRequest::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CloseRoomRequest::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CloseRoomRequest::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CloseRoomRequest::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& CloseRoomRequest::roomid() const {
  // @@protoc_insertion_point(field_get:CloseRoomRequest.RoomId)
  return *roomid_;
}
inline void CloseRoomRequest::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
  // @@protoc_insertion_point(field_set:CloseRoomRequest.RoomId)
}
inline void CloseRoomRequest::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
  // @@protoc_insertion_point(field_set_char:CloseRoomRequest.RoomId)
}
inline void CloseRoomRequest::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CloseRoomRequest.RoomId)
}
inline ::std::string* CloseRoomRequest::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CloseRoomRequest.RoomId)
  return roomid_;
}
inline ::std::string* CloseRoomRequest::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CloseRoomRequest::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CloseRoomRequest.RoomId)
}

// required int32 reason = 2;
inline bool CloseRoomRequest::has_reason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CloseRoomRequest::set_has_reason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CloseRoomRequest::clear_has_reason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CloseRoomRequest::clear_reason() {
  reason_ = 0;
  clear_has_reason();
}
inline ::google::protobuf::int32 CloseRoomRequest::reason() const {
  // @@protoc_insertion_point(field_get:CloseRoomRequest.reason)
  return reason_;
}
inline void CloseRoomRequest::set_reason(::google::protobuf::int32 value) {
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:CloseRoomRequest.reason)
}

// -------------------------------------------------------------------

// CloseRoomResponse

// required int32 result = 1;
inline bool CloseRoomResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CloseRoomResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CloseRoomResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CloseRoomResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 CloseRoomResponse::result() const {
  // @@protoc_insertion_point(field_get:CloseRoomResponse.result)
  return result_;
}
inline void CloseRoomResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CloseRoomResponse.result)
}

// -------------------------------------------------------------------

// RoomCloseBroadcast_Statement

// required int64 likeTotal = 1;
inline bool RoomCloseBroadcast_Statement::has_liketotal() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomCloseBroadcast_Statement::set_has_liketotal() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomCloseBroadcast_Statement::clear_has_liketotal() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomCloseBroadcast_Statement::clear_liketotal() {
  liketotal_ = GOOGLE_LONGLONG(0);
  clear_has_liketotal();
}
inline ::google::protobuf::int64 RoomCloseBroadcast_Statement::liketotal() const {
  // @@protoc_insertion_point(field_get:RoomCloseBroadcast.Statement.likeTotal)
  return liketotal_;
}
inline void RoomCloseBroadcast_Statement::set_liketotal(::google::protobuf::int64 value) {
  set_has_liketotal();
  liketotal_ = value;
  // @@protoc_insertion_point(field_set:RoomCloseBroadcast.Statement.likeTotal)
}

// required int64 postsTotal = 2;
inline bool RoomCloseBroadcast_Statement::has_poststotal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomCloseBroadcast_Statement::set_has_poststotal() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomCloseBroadcast_Statement::clear_has_poststotal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomCloseBroadcast_Statement::clear_poststotal() {
  poststotal_ = GOOGLE_LONGLONG(0);
  clear_has_poststotal();
}
inline ::google::protobuf::int64 RoomCloseBroadcast_Statement::poststotal() const {
  // @@protoc_insertion_point(field_get:RoomCloseBroadcast.Statement.postsTotal)
  return poststotal_;
}
inline void RoomCloseBroadcast_Statement::set_poststotal(::google::protobuf::int64 value) {
  set_has_poststotal();
  poststotal_ = value;
  // @@protoc_insertion_point(field_set:RoomCloseBroadcast.Statement.postsTotal)
}

// required int32 onlineTotal = 3;
inline bool RoomCloseBroadcast_Statement::has_onlinetotal() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomCloseBroadcast_Statement::set_has_onlinetotal() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomCloseBroadcast_Statement::clear_has_onlinetotal() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomCloseBroadcast_Statement::clear_onlinetotal() {
  onlinetotal_ = 0;
  clear_has_onlinetotal();
}
inline ::google::protobuf::int32 RoomCloseBroadcast_Statement::onlinetotal() const {
  // @@protoc_insertion_point(field_get:RoomCloseBroadcast.Statement.onlineTotal)
  return onlinetotal_;
}
inline void RoomCloseBroadcast_Statement::set_onlinetotal(::google::protobuf::int32 value) {
  set_has_onlinetotal();
  onlinetotal_ = value;
  // @@protoc_insertion_point(field_set:RoomCloseBroadcast.Statement.onlineTotal)
}

// required int32 duration = 4;
inline bool RoomCloseBroadcast_Statement::has_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomCloseBroadcast_Statement::set_has_duration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomCloseBroadcast_Statement::clear_has_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomCloseBroadcast_Statement::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline ::google::protobuf::int32 RoomCloseBroadcast_Statement::duration() const {
  // @@protoc_insertion_point(field_get:RoomCloseBroadcast.Statement.duration)
  return duration_;
}
inline void RoomCloseBroadcast_Statement::set_duration(::google::protobuf::int32 value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:RoomCloseBroadcast.Statement.duration)
}

// -------------------------------------------------------------------

// RoomCloseBroadcast

// required .RoomCloseBroadcast.Statement statement = 1;
inline bool RoomCloseBroadcast::has_statement() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomCloseBroadcast::set_has_statement() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomCloseBroadcast::clear_has_statement() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomCloseBroadcast::clear_statement() {
  if (statement_ != NULL) statement_->::RoomCloseBroadcast_Statement::Clear();
  clear_has_statement();
}
inline const ::RoomCloseBroadcast_Statement& RoomCloseBroadcast::statement() const {
  // @@protoc_insertion_point(field_get:RoomCloseBroadcast.statement)
  return statement_ != NULL ? *statement_ : *default_instance_->statement_;
}
inline ::RoomCloseBroadcast_Statement* RoomCloseBroadcast::mutable_statement() {
  set_has_statement();
  if (statement_ == NULL) statement_ = new ::RoomCloseBroadcast_Statement;
  // @@protoc_insertion_point(field_mutable:RoomCloseBroadcast.statement)
  return statement_;
}
inline ::RoomCloseBroadcast_Statement* RoomCloseBroadcast::release_statement() {
  clear_has_statement();
  ::RoomCloseBroadcast_Statement* temp = statement_;
  statement_ = NULL;
  return temp;
}
inline void RoomCloseBroadcast::set_allocated_statement(::RoomCloseBroadcast_Statement* statement) {
  delete statement_;
  statement_ = statement;
  if (statement) {
    set_has_statement();
  } else {
    clear_has_statement();
  }
  // @@protoc_insertion_point(field_set_allocated:RoomCloseBroadcast.statement)
}

// required int32 reason = 2;
inline bool RoomCloseBroadcast::has_reason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomCloseBroadcast::set_has_reason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomCloseBroadcast::clear_has_reason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomCloseBroadcast::clear_reason() {
  reason_ = 0;
  clear_has_reason();
}
inline ::google::protobuf::int32 RoomCloseBroadcast::reason() const {
  // @@protoc_insertion_point(field_get:RoomCloseBroadcast.reason)
  return reason_;
}
inline void RoomCloseBroadcast::set_reason(::google::protobuf::int32 value) {
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:RoomCloseBroadcast.reason)
}

// -------------------------------------------------------------------

// MakeUserSilenceRequest

// required string UserId = 1;
inline bool MakeUserSilenceRequest::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MakeUserSilenceRequest::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MakeUserSilenceRequest::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MakeUserSilenceRequest::clear_userid() {
  if (userid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& MakeUserSilenceRequest::userid() const {
  // @@protoc_insertion_point(field_get:MakeUserSilenceRequest.UserId)
  return *userid_;
}
inline void MakeUserSilenceRequest::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
  // @@protoc_insertion_point(field_set:MakeUserSilenceRequest.UserId)
}
inline void MakeUserSilenceRequest::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
  // @@protoc_insertion_point(field_set_char:MakeUserSilenceRequest.UserId)
}
inline void MakeUserSilenceRequest::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MakeUserSilenceRequest.UserId)
}
inline ::std::string* MakeUserSilenceRequest::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MakeUserSilenceRequest.UserId)
  return userid_;
}
inline ::std::string* MakeUserSilenceRequest::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MakeUserSilenceRequest::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MakeUserSilenceRequest.UserId)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_LivePackage_5fclient_2eproto__INCLUDED
